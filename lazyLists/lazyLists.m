(* Wolfram Language Package *)

(* Created by the Wolfram Workbench 18-Sep-2018 *)
ClearAll["lazyLists`*", "lazyLists`Private`*"];

BeginPackage["lazyLists`"]
(* Exported symbols added here with SymbolName::usage *) 

lazyList::usage = "lazyList is linked list data structure that should contain 2 elements: the first is the first element, the second a held expression that will generate the next linked list when evaluated.
You can extract these elements with First and Last. Part and Take will not work because they have been overloaded with special functionalities when used on lazyList.
lazyList[list] or lazyList[Hold[var]] is a special constructor that generates a lazyList from an ordinary list";

lazyRange::usage = "lazyRange[] is a lazy representation of the Integers from 1 to \[Infinity]. lazyRange[min, delta] represents values values from min onwards in steps of delta. lazyRange has no upper limit";

lazyPowerRange::usage = "lazyPowerRange[min, r] is the infinite list {min, r \[Times] min, r^2 \[Times] min, ...}";

lazyNestList::usage = "lazyNestList[f, elem] is the infinite list {elem, f[elem], f[f[elem]], ...} starting with elem and generated by iterating f repeatedly";

lazyStream::usage = "lazyStream[streamObject] creates a lazyList that streams from streamObject. These streams will stop automatically when EndOfFile is reached";

lazyConstantArray::usage = "lazyConstantArray[elem] produces an infinite list of copies of elem";

lazyMapThread::usage = "lazyMapThread[f, {lz1, lz2, ...}] is similar to MapThread, except all elements from the lazyLists are fed to the first slot of f as a regular List"

lazyTranspose::usage = "lazyTranspose[{lz1, lz2, ...}] creates a lazyList with tuples of elements from lz1, lz2, etc. 
Equivalent to lazyMapThread[Identity, {lz1, lz2, ...}]"

$lazyIterationLimit::usage = "Iteration limit used for finding successive elements in a lazy list";

Begin["`Private`"]
(* Implementation of the package *)

$lazyIterationLimit = Infinity;

Attributes[lazyList] = {HoldRest};

lazyList[list_List] := Module[{
    listVar = list
},
    lazyList[Hold[listVar]]
];

lazyList[Hold[list_Symbol]] := With[{
    msgs = {Part::partw}
},
    Function[
        Quiet[
            Check[
                lazyList[
                    list[[#1]],
                    #0[#1 + 1]
                ],
                lazyList[],
                msgs
            ],
            msgs
        ]
    ][1]
];

(* For efficiency reasons, these lazy list generatorss are defined by self-referential anynomous functions. Note that #0 refers to the function itself *)
lazyRange[start : _ : 1, step : _ : 1] /; !TrueQ[step == 0] := Function[
    lazyList[#1, #0[#2 + #1, #2]]
][start, step];

lazyRange[start_, step_ /; TrueQ[step == 0]] := lazyConstantArray[start];

lazyPowerRange[start_, r_ /; !TrueQ[r == 1]] := Function[
    lazyList[#1, #0[#2 * #1, #2]]
][start, r];

lazyPowerRange[min_, r_ /; TrueQ[r == 1]] := lazyConstantArray[min]

lazyNestList[f_, elem_] := Function[
    lazyList[
        #1,
        #0[f[#1], #2 + 1]
    ]
][elem, 1];

lazyStream[stream_InputStream] := Function[
    With[{
        read = Read[#1]
    },
        lazyList[
            read,
            If[ read =!= EndOfFile,
                #0[#1, #2 + 1], (* Increase an iterator to make sure that ReplaceRepeated in Take doesn't stop *)
                lazyList[] (* return an empty lazyList to end stream *)
            ]
        ]
    ]
][stream, 1];

lazyConstantArray[const_] := Function[
    lazyList[
        const,
        (* Increase an iterator to make sure that ReplaceRepeated in Take doesn't stop *)
        #0[#1 + 1]
    ]
][1];

(* Set threading behaviour for lazyLists to make it possible to add and multiply them and use powers on them *)
lazyThreading = True;

lazyList /: (op : Plus | Times)[first___, l__lazyList, rest___] /; lazyThreading :=  Block[{
    lazyThreading = False
},
    Thread[Unevaluated[op[first, l, rest]], lazyList]
];

lazyList /: (op : Power | Divide | Subtract)[l_lazyList, rest_] /; lazyThreading :=  Block[{
    lazyThreading = False
},
    Thread[Unevaluated[op[l, rest]], lazyList]
];
lazyList /: (op : Power | Divide | Subtract)[first_, l_lazyList] /; lazyThreading :=  Block[{
    lazyThreading = False
},
    Thread[Unevaluated[op[first, l]], lazyList]
];

(* Elements from lazyLists are extracted by repeatedly evaluating the next element and sowing the results *)
lazyList /: Take[l_lazyList, n_Integer?Positive] := MapAt[
    First[#, {}]&,
    Reverse @ Reap[
        Replace[
            Quiet[
                Block[{$IterationLimit = $lazyIterationLimit},
                    ReplaceRepeated[
                        l,
                        {
                            lazyList[first_, last_] :> (Sow[first, "take"]; last)
                        },
                        MaxIterations -> n - 1
                    ]
                ],
                {ReplaceRepeated::rrlim}
            ],
            (* The last element should only be Sown without evaluating the next element *)
            lazyList[first_, last_] :> (Sow[first, "take"]; lazyList[first, last]) 
        ],
        "take"
    ],
    1
];

lazyList /: TakeWhile[l_lazyList, function_, OptionsPattern[MaxIterations -> Infinity]] := MapAt[
    First[#, {}]&,
    Reverse @ Reap[
        Quiet[
            Catch[
                Block[{$IterationLimit = $lazyIterationLimit},
                    ReplaceRepeated[
                        l,
                        {
                            lazyList[first_, last_] :> If[function[first]
                                ,
                                Sow[first, "take"];
                                last
                                ,
                                Throw[lazyList[first, last], "break"],
                                Throw[lazyList[first, last], "break"]
                            ]
                        },
                        MaxIterations -> OptionValue[MaxIterations]
                    ]
                ],
                "break"
            ],
            {ReplaceRepeated::rrlim}
        ],
        "take"
    ],
    1
];

lazyList /: Part[l_lazyList, 1] := l;
lazyList /: Part[l_lazyList, n_Integer] := Quiet[
    Block[{$IterationLimit = $lazyIterationLimit},
        ReplaceRepeated[
            l,
            {
                lazyList[first_, last_] :> last
            },
            MaxIterations -> n - 1
        ]
    ],
    {ReplaceRepeated::rrlim}
];

lazyList /: Map[f_, lazyList[fst_, last_]] := lazyList[
    f[fst],
    Map[f, last]
];

lazyList /: MapIndexed[f_, lazyList[fst_, last_], index : (_Integer?Positive) : 1] := lazyList[
    f[fst, index],
    MapIndexed[f, last, index + 1]
];

lazyMapThread[f_, list : {lazyList[_, _]..}] := lazyList[
    f[list[[All, 1]]],
    lazyMapThread[f, list[[All, 2]]]
];

lazyMapThread[_, _] := lazyList[];

lazyTranspose[list : {__lazyList}] := lazyMapThread[Identity, list];

lazyList /: FoldList[f_, lazyList[first_, last_]] := FoldList[f, first, last];

lazyList /: FoldList[f_, current_, lazyList[first_, last_]] := lazyList[
    current,
    FoldList[f, f[current, first], last]
];

lazyList /: FoldList[f_, current_, empty : lazyList[]] := lazyList[current, empty];

lazyList /: Cases[l_lazyList, patt_] := Module[{
    case
 },
    (* Define helper function to match patterns faster *)
    case[lazyList[first : patt, last_]] := lazyList[first, case[last]];
    case[lazyList[first_, last_]] := case[last];
    
    case[l]
];

lazyList /: Pick[l_lazyList, select_lazyList, patt_] := Module[{
    pick
},
    (* Define helper function, just like with Cases *)
    pick[lazyList[first_, last1_], lazyList[match : patt, last2_]] :=
        lazyList[first, pick[last1, last2]];
    pick[lazyList[first_, last1_], lazyList[first2_, last2_]] :=
        pick[last1, last2];
        
    pick[l, select] 
];

lazyList /: Select[lazyList[first_, last_], f_] /; f[first] := lazyList[first, Select[last, f]];
lazyList /: Select[lazyList[first_, last_], f_] := Select[last, f];

End[]

EndPackage[]

