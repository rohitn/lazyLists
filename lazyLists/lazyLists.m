(* Wolfram Language Package *)

(* Created by the Wolfram Workbench 18-Sep-2018 *)
ClearAll["lazyLists`*", "lazyLists`Private`*"];

BeginPackage["lazyLists`"]
(* Exported symbols added here with SymbolName::usage *) 

lazyList::usage = "lazyList is linked list data structure that should contain 2 elements: the first is the first element, the second a held expression that will generate the next linked list when evaluated.
You can extract these elements with First and Last. Part and Take will not work because they have been overloaded with special functionalities when used on lazyList";

lazyRange::usage = "lazyRange[] is a lazy representation of the Integers from 1 to \[Infinity]. lazyRange[min, delta] represents values values from min onwards in steps of delta";

lazyPowerRange::usage = "lazyPowerRange[min, r] is the infinite list {min, r \[Times] min, r^2 \[Times] min, ...}";

lazyNestList::usage = "lazyNestList[f, elem] is the infinite list {elem, f[elem], f[f[elem]], ...} starting with elem and generated by iterating f repeatedly";

lazyStream::usage = "lazyStream[streamObject] creates a lazyList that streams from streamObject";

Begin["`Private`"]
(* Implementation of the package *)

Attributes[lazyList] = {HoldRest};

(* All generating lazy lists are defined by self-referential anynomous functions. Note that #0 refers to the function itself *)
lazyRange[min : _ : 1, step : _ : 1] := Function[
    lazyList[#1, #0[#2 + #1, #2]]
][min, step];

lazyPowerRange := Function[
    lazyList[#1, #0[#2 * #1, #2]]
];

lazyNestList[f_, elem_] := Function[
    lazyList[
        #1,
        #0[f[#1]]
    ]
][elem];

lazyStream[stream_InputStream] := Function[
    lazyList[
        Read[#],
        #0[#]
    ]
][stream];

(* Elements from lazyLists are extracted by repeatedly evaluating the next element and sowing the results *)
lazyList /: Take[l_lazyList, n_Integer /; n > 0] := MapAt[
    First[#, {}]&,
    Reverse @ Reap[
        Replace[
            Quiet[
                ReplaceRepeated[
                    l,
                    {
                        lazyList[first_, last_] :> (Sow[first, "take"]; last)
                    },
                    MaxIterations -> n - 1
                ],
                {ReplaceRepeated::rrlim}
            ],
            (* The last element should only be Sown without evaluating the next element *)
            lazyList[first_, last_] :> (Sow[first, "take"]; lazyList[first, last]) 
        ],
        "take"
    ],
    1
];

lazyList /: TakeWhile[l_lazyList, function_, OptionsPattern[MaxIterations -> Infinity]] := MapAt[
    First[#, {}]&,
    Reverse @ Reap[
        Quiet[
            Catch[
                ReplaceRepeated[
                    l,
                    {
                        lazyList[first_, last_] :> If[function[first]
                            ,
                            Sow[first, "take"];
                            last
                            ,
                            Throw[lazyList[first, last], "break"],
                            Throw[lazyList[first, last], "break"]
                        ]
                    },
                    MaxIterations -> OptionValue[MaxIterations]
                ],
                "break"
            ],
            {ReplaceRepeated::rrlim}
        ],
        "take"
    ],
    1
];

lazyList /: Part[l_lazyList, 1] := l;
lazyList /: Part[l_lazyList, n_Integer] := Quiet[
    ReplaceRepeated[
        l,
        {
            lazyList[first_, last_] :> last
        },
        MaxIterations -> n - 1
    ],
    {ReplaceRepeated::rrlim}
];

lazyList /: Map[f_, lazyList[fst_, last_]] := lazyList[
    f[fst],
    Map[f, last]
];

lazyList /: FoldList[f_, elem_, l_lazyList] := FoldList[f, lazyList[elem, l]];

lazyList /: FoldList[f_, lazyList[first_, last_]] := With[{
    l = last
},
    lazyList[
        first,
        FoldList[f, lazyList[f[first, First[l]], Last[l]]]
    ]
]; 

lazyList /: Cases[l_lazyList, patt_] := Module[{
    case
 },
    (* Define helper function to match patterns faster *)
    case[lazyList[first : patt, last_]] := lazyList[first, case[last]];
    case[lazyList[first_, last_]] := case[last];
    
    case[l]
];

lazyList /: Pick[l_lazyList, select_lazyList, patt_] := Module[{
    pick
},
    (* Define helper function, just like with Cases *)
    pick[lazyList[first_, last1_], lazyList[match : patt, last2_]] :=
        lazyList[first, pick[last1, last2]];
    pick[lazyList[first_, last1_], lazyList[first2_, last2_]] :=
        pick[last1, last2];
        
    pick[l, select] 
];

lazyList /: Select[lazyList[first_, last_], f_] /; f[first] := lazyList[first, Select[last, f]];
lazyList /: Select[lazyList[first_, last_], f_] := Select[last, f];

End[]

EndPackage[]

